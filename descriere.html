
<!DOCTYPE html>
<html lang="ro">
<head>
  <title>Inversarea unei matrice</title>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<style>

#pozameniu{

background-image: url("img/pozabara.jpg");
  background-repeat: repeat-x;
}


#myBtn {
  display: none;
  position: fixed;
  bottom: 20px;
  right: 30px;
  z-index: 99;
  font-size: 18px;
  border: none;
  outline: none;
  background-color: lightblue;
  color: white;
  cursor: pointer;
  padding: 15px;
  border-radius: 4px;
}
#myBtn:hover {
  background-color: #555;
}
	
	p.detalii{
		font-family: Lucida Sans Unicode;
		font-size: 17px;
		text-indent: 50px;
		text-align: justify;
		text-align: center;
		padding-top: 160px;
		padding-right: 80px;
		padding-bottom: 50px;
		padding-left: 80px;
}
	h3{
		align:center;
		color:lightblue;
		}
	p.multumiri{
	text-decoration: overline; 
	text-align:right;
	}
	div.multumiri{
		position:absolute;
		bottom:10px;
		right:10px;
	}
	
	.hero-text {
  text-align: center;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: white;
}

  
</style>
</head>
<body style="height:1500px">


<nav class="navbar navbar-inverse  navbar-fixed-top">
  <div class="container-fluid">
    <div class="navbar-header">
      <a class="navbar-brand" title="nume">Inversa unei matrice</a>
    </div>
    <ul class="nav navbar-nav">
	  <li><a title="proiect" href='index.html'>	Acasă	</a></li>
	  <li><a title="aplicatii" href='info.html'>	Teorie	</a></li>
	  
      <li><a title="cod" href='paginacod.php'>		Aplicație 	</a></li>
      <li class="active"><a title="sugestii" href='descriere.html'>	Descriere </a></li>
      <li><a title="sugestii" href='paginasugestii.html'>	Alte idei/sugestii	</a></li>
      <li><a title="autor" href='paginaautor.html'>	Despre autor	</a></li>
	  <li><a title="bibliografie" href='paginabibliografie.html'>	Bibliografie	</a></li>
    </ul>
  </div>
</nav>

<div  id="pozameniu">
<br><br><br><br><br>

  <h1 style="font-size:50px; text-align: center; color: white; font-family:fantasy;">INVERSAREA UNEI MATRICE</h1>
	
<br><br><br><br><br><br>
</div>

<div class="row">
  <div class="container"  style="margin-top:50px">
  
  <div class="c++ code">
	<H1>Inversa unei matrice</H1>
	<p>Aceast proiect conţine  formulare,  precum <code>&#60;form action="atestat.php" method="post"&#62; <br>
	&#60;textarea name="text" rows="10" cols="30">Scrie aici matricea.&#60;/textarea&#62;<br>
	&#60;input type="submit" name="buton" value="submit"&#62;<br>
	&#60;/form&#62; </code> şi funcții în php explicate mai jos. </p>


 <H3>Funcţia transpusă</H3>
 
 <p>Funcţia pentru transpusă folosește un tablou bidimensional adiacent <code>&#36;B </code>  unde va fi interschimbată 
 linia cu coloana din tabloul transmis ca parametru <code>&#36;A </code> : <br>
 <code>&#36;B[&#36;i][&#36;j]=&#36;A[&#36;j][&#36;i];</code>.
 
 </p>
 
 <pre>
 <code>
	function transpusa(& &#36;A,&#36;n)
		{
			&#36;B = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			for(&#36;i=1;&#36;i&#60;=$n;&#36;i++)
				for(&#36;j=1;&#36;j&#60;=&#36;n;&#36;j++)
					&#36;B[&#36;i][&#36;j]=&#36;A[&#36;j][&#36;i];
			&#36;A=&#36;B;
			
		}
</code>
</pre>

<H3>Funcţia de afişare</H3>
<p>Această funcţie afişează matricea sau mai bine zis- tabloul bidimensional transmis ca parametru. 
Ea parcurge tabloul pe linii și coloane, afișând numerele pe rând.<br>
<code>&amp;nbsp;</code> este folosit pentru a crea o spațiere adecvată astfel încât matricea să fie afișată corect.
</p>
<pre>
<code>
	function afisare(&#36;A,&#36;n)
		{
			for(&#36;i=1;&#36;i&#60;=&#36;n;&#36;i++)
			{
				for(&#36;j=1;&#36;j&#60;=&#36;n;&#36;j++)
					echo &#36;A[&#36;i][&#36;j], "&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"; 
				echo "<br>";
			}
		}
</code>
</pre>

<H3>Funcţia determinant</H3>
<p>Această funcţie  calculeaza determinantul unei matrice transmisă ca parametru:<code>&#36;A </code> de dimensiune:
<code>&#36;n</code><br> 
Algoritmul de calcul al determinantului unei matrice se bazează pe transformarea determinantului într-un determinant superior triunghiular, iar calculul valorii determinantului se reduce la a determina produsul elementelor de pe diagonala principală a acestuia.
Transformarea determinantului, bazată pe proprietățile matematice ale determinanților, se realizează astfel (presupunem că elementele de sub diagonala principală, aflate pe coloanele 1, 2, …, i – 1 au fost făcute 0 și ne aflăm la pasul i):
<br>Pas 1) Alegem valoarea maximă din subdeterminatul având vârfurile opuse de coordonate (i,i), respectiv (n,n), pentru a ne asigura că valoarea determinantului va fi cât mai aproape de valoarea reală.
<br>Pas 2) Maximul determinat va fi mutat pe poziția (i,i) prin interschimbări de linii și/sau coloane, modificând semnul determinantului, dacă este cazul;
<br>Pas 3) Pentru fiecare dintre liniile j= i+1, i+2, …, n:
<br>-	Determinăm valoarea alfa cu care trebuie înmulțită linia i astfel încât, după adunarea acesteia la linia j, elementul a<sub>ji</sub> să devină 0;
<br>-	Adunăm, element cu element, linia i (înmulțită cu alfa), cu linia j;
<br>Pașii 1 – 3 se execută de n – 1 ori.

</p>
<pre>
<code>
	function determinant(&#36;A,&#36;n)
		{
			&#36;B = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			&#36;B=&#36;A;
			&#36;max=0;
			&#36;semn=0;
			
			for(&#36;i=1;&#36;i&#60;=&#36;n-1;&#36;i++)
			{
				//caut maximul
				&#36;indi=&#36;indj=0;
				&#36;max= -1000000000;
				for(&#36;m=&#36;i;&#36;m&#60;=&#36;n;&#36;m++)
					for(&#36;k=&#36;i;&#36;k&#60;=&#36;n;&#36;k++)
					{
						if(&#36;B[&#36;m][&#36;k]&#62;&#36;max && &#36;B[&#36;m][&#36;k] != 0)
						{
							&#36;max=&#36;B[&#36;m][&#36;k];
							&#36;indi=&#36;m;//linie
							&#36;indj=&#36;k;//coloana
						}
					
					}
				if(&#36;indi != &#36;i) &#36;semn++;
				if(&#36;indj != &#36;i) &#36;semn++;
				for(&#36;m=&#36;i;&#36;m&#60;=&#36;n;&#36;m++) //mut orizontal liniile 
				{
					&#36;aux=&#36;B[&#36;i][&#36;m];
					&#36;B[&#36;i][&#36;m]=&#36;B[&#36;indi][&#36;m];
					&#36;B[&#36;indi][&#36;m]=&#36;aux;
					
				}
				for(&#36;m=&#36;i;&#36;m&#60;=&#36;n;&#36;m++) //mut vertical coloanele
				{
					$aux=$B[&#36;m][&#36;i];
					&#36;B[&#36;m][&#36;i]=&#36;B[&#36;m][&#36;indj];
					&#36;B[&#36;m][&#36;indj]=&#36;aux;
				}
					
					
				for(&#36;j=&#36;i+1;&#36;j&#60;=&#36;n;&#36;j++)
					if(&#36;B[&#36;j][&#36;i] != 0)
				{
					&#36;alfa= (-&#36;B[&#36;j][&#36;i]/&#36;B[&#36;i][&#36;i]);

					for(&#36;k=&#36;i;&#36;k&#60;=&#36;n;&#36;k++)
						&#36;B[&#36;j][&#36;k]=&#36;B[&#36;j][&#36;k]+&#36;alfa*&#36;B[&#36;i][&#36;k];
					
				}

			}
			&#36;P=1;
			for(&#36;i=1;&#36;i&#60;=&#36;n;&#36;i++)
				&#36;P=&#36;P*&#36;B[&#36;i][&#36;i];
			if( &#36;semn % 2 ) &#36;P = -&#36;P;
			return &#36;P;
		}
</code>
</pre>

<H3>Funcţia minor</H3>
<p>Această funcţie calculează minorul unei matrice transmisă prin parametrul:<code>&#36;A </code> conform formulei de calcul pentru un minor  (explicată la "Teorie")
. Astfel că pentru fiecare
element <code>B<sub>ij</sub></code>se calculează determinantul rămas prin eliminarea coloanei j și a liniei i. <br></p>


<pre>
<code>
function minor(&#36;A,&#36;n,&#36;i,&#36;j)
		{
			&#36;B = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			&#36;B=&#36;A;
			&#36;det=0;
			for(&#36;f=1;&#36;f&#60;=$n;&#36;f++) //elimin  linia i
				for(&#36;k=&#36;i+1;&#36;k&#60;=&#36;n;&#36;k++)
					&#36;B[&#36;k-1][&#36;f]=&#36;B[&#36;k][&#36;f];
			for(&#36;f=1;&#36;f&#60;&#36;n;&#36;f++) //elimin coloana j
				for(&#36;k=&#36;j+1;&#36;k&#60;=&#36;n;&#36;k++)
					&#36;B[&#36;f][&#36;k-1]=&#36;B[&#36;f][&#36;k];
			&#36;n--;

			if((&#36;i+&#36;j)%2==0) &#36;det=determinant(&#36;B,&#36;n);
			else &#36;det=-determinant(&#36;B,&#36;n);
			
			return &#36;det;
		}
</code>
</pre>


<H3>Funcţia adjunctă </H3>
<p>Această funcție determină adjuncta matricei,apelând pentru fiecare numar, minor din acel numar. Dupa urmatoarea formula:<br> 
<img src="31.jpg"> unde D<sub>11</sub>,D<sub>12</sub>.....D<sub>nn</sub> reprezinta determinantul obtinut din transpusa matricei,prin eliminarea liniei si a coloanei numarului.</p>
<pre>
<code>
function adjuncta(&#36;A,&#36;n)
		 {
			 	&#36;Adj = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			for(&#36;i=1;&#36;i&#60;=&#36;n;&#36;i++)
			{
				for(&#36;j=1;&#36;j&#60;=&#36;n;&#36;j++)
					&#36;Adj[&#36;i][&#36;j] = minor(&#36;A, &#36;n, &#36;i, &#36;j);
			}
			return &#36;Adj;
			 
		 }
</code>
</pre>



<H3>Funcţia înmulțire</H3>

<p> Această funcţie realizează înmulţirea necesară formulei:<img src="32.jpg">  între  <code>&#36;k </code>- adică 1/det(A)-  şi matricea transmisă prin parametru  <code>&#36;A</code>.
Rezultatul înmulțirii e memorat într-o altă matrice <code>&#36;B</code> care va fi returnată.</p>
<pre>
<code>
function inmultire(&#36;A,&#36;n,&#36;k)
		 {
			 
			 &#36;B = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			for(&#36;i=1;&#36;i&#60;=&#36;n;&#36;i++)
				for(&#36;j=1;&#36;j&#60;=&#36;n;&#36;j++)
					&#36;B[&#36;i][&#36;j]=&#36;A[&#36;i][&#36;j]*&#36;k;
			return &#36;B;
			
			
			 
		 }
</code>
</pre>

<H3>Funcţia  inversă</H3>
<p>Aici se calculează propriu-zis inversa matricei, prin apelarea funcțiilor adiacente. În<code>&#36;B</code> se va memora adjuncta matricei <code>&#36;A</code>. 
Iar în  <code>&#36;inv</code> se va memora inversa conform formulei: <img src="32.jpg"> unde 1/det(A) îl reprezintă <code>&#36;k</code>.</p>
<pre>
<code>
 function inversa(&#36;A,&#36;n)
		 {
			 &#36;B = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			&#36;inv = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			&#36;k=1/determinant(&#36;A,&#36;n);
			 transpusa(&#36;A,&#36;n);
			 &#36;B=adjuncta(&#36;A,&#36;n);
			 &#36;inv=inmultire(&#36;B,&#36;n,&#36;k);
			 return &#36;inv;
			 
		 }
</code>
</pre>



<H3>Citirea formularului și transformarea acestuia într-o matrice</H3>

<p>Aici se verifică dacă s-a trimis ceea ce a tastat utilizatorul în caseta text. Datele sunt extrase într-un șir de caractere <code>&#36;text</code>
 care va fi mai apoi separat pe linii cu ajutorului unui alt șir: <code>&#36;V1=explode(';',&#36;text); </code> și mai apoi folosind un al doilea șir și pe coloane:<code>&#36;V2=
 explode(',',&#36;V1[&#36;i]); </code> Acest ultim șir se va memora caracter cu caracter în matricea:<code>&#36;A </code>:<br> <code>&#36;A[&#36;i+1][&#36;j+1]=&#36;V2[&#36;j];	</code>
<br>
Prin aplerea funcțiilor(afisare,inversa) și funcțiile asociate lor, pe ecran va apărea rezultatul dorit.<code>afisare(inversa(&#36;A,&#36;n),&#36;n); </code>

<pre>
<code>
 if(isset(&#36;_POST['buton']))
		{
			&#36;text=&#36;_POST['text'];
			&#36;A = array( array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0), array(0,0,0,0,0,0,0,0,0,0),array(0,0,0,0,0,0,0,0,0,0), 
						array(0,0,0,0,0,0,0,0,0,0));
			
			
			&#36;V1=explode(';',&#36;text);
			&#36;n=count(&#36;V1)-1;
			for(&#36;i=0;$i&#60;count(&#36;V1)-1;&#36;i++)
			{	
				&#36;V2=explode(',',&#36;V1[&#36;i]);
				for(&#36;j=0;&#36;j&#60;count(&#36;V2);&#36;j++)
					&#36;A[&#36;i+1][&#36;j+1]=&#36;V2[&#36;j];	
			}
			 //calculul efectiv al inversei unui numar:
			 
			 
			
			afisare(inversa(&#36;A,&#36;n),&#36;n);
</code>
</pre>

  </div>
</div> 

<div class="row">
  <div class="col-lg-12" style="background-color:black;">
  
  <h5 style="font-size:10px; text-align: center; color: white; ">Acest proiect a fost realizat sub îndrumarea profesorului Alin Burța-C.N. ,,B.P. Hasdeu"</h5>
  
  </div>
</div> 
  
 
 <script>
// Cand utilizatorul da scroll 20px, apare butonul
window.onscroll = function() {scrollFunction()};

function scrollFunction() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
        document.getElementById("myBtn").style.display = "block";
    } else {
        document.getElementById("myBtn").style.display = "none";
    }
}

//Cand utilizatorul apasa butonul, il duce la inceputul paginii
function topFunction() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
}
</script>




</body>
</html>
